from pwn import *
import json
#context.log_level = 'debug'
DIM = 10
DIMS = 4

def readmaze(p, dims):
	if dims == 1:
		row = p.recvuntil("\n").decode().strip()
		return row
	level = []
	for _ in range(DIM):
		level.append(readmaze(p, dims-1))
	return level

def loadmaze():
	with open("maze.save") as inf:
		return json.load(inf)

def savemaze(maze):
	with open("maze.save", "w") as outf:
		json.dump(maze, outf, indent='\t')

if True:
	p = remote("chal.imaginaryctf.org", 42017)
	p.recvuntil(":\n")
	maze = readmaze(p, DIMS)
	savemaze(maze)
else:
	maze = loadmaze()

# Seems to be hardcoded
start = tuple(0 for _ in range(DIMS))
end = tuple(DIM-1 for _ in range(DIMS))

# Do a Depth First Search (DFS) from end to start
# We save the path to get to X in visited[X]
visited = {} # not the best regarding performance, but who cares in this small maze
qu = [end] # queue with points to further explore
visited[end] = ""
while True:
	cur = qu.pop()
	if cur == start:
		break
	
	for dim in range(DIMS): # for each possible dimension
		for diff in [-1, 1]: # go one in each direction
			newpos = list(cur)
			newpos[dim] += diff
			if newpos[dim] < 0 or newpos[dim] >= DIM: # outside maze
				continue
			newpos = tuple(newpos)
			if newpos in visited: # already been there
				continue
			if maze[newpos[0]][newpos[1]][newpos[2]] == "#": # a wall
				continue
			cmd = chr(ord('A') + dim)
			if diff == -1:
				cmd = cmd.lower()
			visited[newpos] = visited[cur] + cmd # mark, that we got there and with which command sequence
			qu.append(newpos) # put it to further explore it

log.info("Found path ", visited[start])
p.sendline(visited[start])
print(p.recvrepeat(timeout=3))
